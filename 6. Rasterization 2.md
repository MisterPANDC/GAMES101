![[GAMES101_Lecture_06-1.jpeg]]
反走样

- [00:00:05](https://www.bilibili.com/video/BV1X7411F744?p=6#t=5.27) 
![[GAMES101_Lecture_06-2.jpeg]]

![[GAMES101_Lecture_06-3.jpeg]]

# Antialiasing
![[GAMES101_Lecture_06-4.jpeg]]

回顾一下，之前我们看每个点是在三角形内还是外部
![[GAMES101_Lecture_06-5.jpeg]]

![[GAMES101_Lecture_06-6.jpeg]]

![[GAMES101_Lecture_06-7.jpeg]]

![[GAMES101_Lecture_06-8.jpeg]]
锯齿jaggies，我们用走样alias来表示
![[GAMES101_Lecture_06-9.jpeg]]

# Sampling is Ubiquitous
我们先分析一下采样的理论
- [00:05:59](https://www.bilibili.com/video/BV1X7411F744?p=6#t=05:59.48) 
![[GAMES101_Lecture_06-10.jpeg]]

![[GAMES101_Lecture_06-11.jpeg]]

![[GAMES101_Lecture_06-12.jpeg]]

![[GAMES101_Lecture_06-13.jpeg]]

![[GAMES101_Lecture_06-14.jpeg]]

![[GAMES101_Lecture_06-15.jpeg]]
除了锯齿，还有摩尔纹这种东西，是因为某些行与列被省略，而导致的
![[GAMES101_Lecture_06-16.jpeg]]

![[GAMES101_Lecture_06-17.jpeg]]

![[GAMES101_Lecture_06-18.jpeg]]
本质都是因为采样跟不上真实的信号
## Blurring before Sampling
![[GAMES101_Lecture_06-19.jpeg]]

![[GAMES101_Lecture_06-20.jpeg]]
一个问题是之前我们的方法，全红要不全白
那么我们加一个渐变的形式，是否可以解决锯齿的问题

![[GAMES101_Lecture_06-21.jpeg]]

因此我们通过一个滤波 模糊来实现反走样
![[GAMES101_Lecture_06-22.jpeg]]

![[GAMES101_Lecture_06-23.jpeg]]

![[GAMES101_Lecture_06-24.jpeg]]

注意一定是先模糊再采样，不能反过来
![[GAMES101_Lecture_06-25.jpeg]]

![[GAMES101_Lecture_06-26.jpeg]]
接下来我们具体分析一下原理
## Frequency Domain
![[GAMES101_Lecture_06-27.jpeg]]
- [00:17:29](https://www.bilibili.com/video/BV1X7411F744?p=6#t=17:29.35) 
![[GAMES101_Lecture_06-28.jpeg]]

![[GAMES101_Lecture_06-29.jpeg]]

傅立叶级数展开，任何一个周期函数，可以用正弦余弦函数表示
![[GAMES101_Lecture_06-30.jpeg]]

傅立叶变换就是通过这种形式
![[GAMES101_Lecture_06-31.jpeg]]

可以把函数变成不同频率的函数
![[GAMES101_Lecture_06-32.jpeg]]
采样的时候，频率越高的函数，采样的效果越差

采样出来的东西，无法确定原来的函数是啥，也就是走样
![[GAMES101_Lecture_06-33.jpeg]]

---
滤波，就相当于将某些频率的内容给去掉
![[GAMES101_Lecture_06-34.jpeg]]

通过频图，可以看到，低频信息多，高频信息少

每当图像剧烈变换的时候，频率就会显得很高
![[GAMES101_Lecture_06-35.jpeg]]

抹去低频信号，然后逆傅立叶变化，就可以看到全是一些边界信息
这种只通过高频信号的过滤就称为高通滤波
![[GAMES101_Lecture_06-36.jpeg]]
因为边界的变化较大，所以频率高

低通滤波
![[GAMES101_Lecture_06-37.jpeg]]

如果留下中间的频率，则会看到不是很明显的边界信息
![[GAMES101_Lecture_06-38.jpeg]]

![[GAMES101_Lecture_06-39.jpeg]]

滤波，就相当于卷积，也就是一种平均
![[GAMES101_Lecture_06-40.jpeg]]

![[GAMES101_Lecture_06-41.jpeg]]

![[GAMES101_Lecture_06-42.jpeg]]

![[GAMES101_Lecture_06-43.jpeg]]

卷积的理论，在spatial domain做卷机相当于在frequency domain做乘法
![[GAMES101_Lecture_06-44.jpeg]]

![[GAMES101_Lecture_06-45.jpeg]]
实际上卷积就是一个滤波的效果
![[GAMES101_Lecture_06-46.jpeg]]

![[GAMES101_Lecture_06-47.jpeg]]

核变大，也就是卷积平均的约定，那么也就越模糊，也就是得到更低的频率
![[GAMES101_Lecture_06-48.jpeg]]

而采样，则相当于重复频率上的内容
![[GAMES101_Lecture_06-49.jpeg]]

我们用c这个冲击函数乘a也就得到了e这个采样的结果，那么在频率上，效果相当于重复频谱
![[GAMES101_Lecture_06-50.jpeg]]

而走样则是因为频谱的重合
![[GAMES101_Lecture_06-51.jpeg]]

![[GAMES101_Lecture_06-52.jpeg]]

![[GAMES101_Lecture_06-53.jpeg]]
那么要么是增加采样率，当然代价就很大
或者反走样，先模糊后采样
模糊也就是低通滤波，拿掉高频率信息然后采样
这样在采样的时候就自然避免了因为频率低而走样的问题
![[GAMES101_Lecture_06-54.jpeg]]

![[GAMES101_Lecture_06-55.jpeg]]

![[GAMES101_Lecture_06-56.jpeg]]
滤波操作，就使用一个低通滤波器即可

一个最简单的方式就是用单个像素做卷积
![[GAMES101_Lecture_06-57.jpeg]]

![[GAMES101_Lecture_06-58.jpeg]]

感觉有点奇怪，但实际上原本连续的图形可能只占一个像素方格中的一部分，那么自然可以做一个平均操作
![[GAMES101_Lecture_06-59.jpeg]]

## Supersamping
![[GAMES101_Lecture_06-60.jpeg]]

上面对一个像素块的覆盖率进行计算，实际上比较困难。因此我们使用一种对反走样的近似方法
![[GAMES101_Lecture_06-61.jpeg]]
对于任意一个像素，我们假设其中有另外一些的小像素点，这样就相当于实现了对大像素覆盖区域的一个近似

![[GAMES101_Lecture_06-62.jpeg]]

![[GAMES101_Lecture_06-63.jpeg]]

![[GAMES101_Lecture_06-64.jpeg]]

![[GAMES101_Lecture_06-65.jpeg]]

![[GAMES101_Lecture_06-66.jpeg]]

![[GAMES101_Lecture_06-67.jpeg]]

![[GAMES101_Lecture_06-68.jpeg]]

![[GAMES101_Lecture_06-69.jpeg]]


- [01:13:51](https://www.bilibili.com/video/BV1X7411F744?p=6#t=1:13:51.38) 

![[GAMES101_Lecture_06-70.jpeg]]

![[GAMES101_Lecture_06-71.jpeg]]