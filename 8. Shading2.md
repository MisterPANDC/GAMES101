![[GAMES101_Lecture_08-1.jpeg]]
- [00:00:07](https://www.bilibili.com/video/BV1X7411F744?p=8#t=7.68) 
![[GAMES101_Lecture_08-2.jpeg]]

![[GAMES101_Lecture_08-3.jpeg]]

![[GAMES101_Lecture_08-4.jpeg]]

![[GAMES101_Lecture_08-5.jpeg]]

![[GAMES101_Lecture_08-6.jpeg]]

# Blinn-Phong Reflection Model
现在开始考虑镜面反射，此时shading就与观测角度view direction相关了
当然，也只有单我们的view direction与reflection direction相近的时候，才能看到镜面反射
![[GAMES101_Lecture_08-7.jpeg]]

blinn-phong 模型则是说，view direction与reflection direction相近相当于半程向量和法线向量很接近
![[GAMES101_Lecture_08-8.jpeg]]
为什么用半程向量，主要是因为好计算
指数p是因为镜面角度的很敏感，因此增加衰减的效果
![[GAMES101_Lecture_08-9.jpeg]]
正常情况下p为100-200
![[GAMES101_Lecture_08-10.jpeg]]

---

# Ambient Term
- [00:15:33](https://www.bilibili.com/video/BV1X7411F744?p=8#t=15:33.61) 
而环境光照下，我们直接假设任意一个地方收到的都是一样的。当然如果要精细的计算就涉及到全局光照，后面再讨论
![[GAMES101_Lecture_08-11.jpeg]]

合起来就是最终的 Bling-Phong Reflection Model
![[GAMES101_Lecture_08-12.jpeg]]

而观测和距离没关系
- [00:19:52](https://www.bilibili.com/video/BV1X7411F744?p=8#t=19:52.93) 
# Shading Frequencies
我们之前考虑的是一个点的着色，那么其实也涉及一个采样的频率问题
![[GAMES101_Lecture_08-15.jpeg]]

flat shading
三角形的表面
![[GAMES101_Lecture_08-16.jpeg]]

gouraud shading
任意一个顶点上求着色
![[GAMES101_Lecture_08-17.jpeg]]

pixel shading
在每个像素上都计算着色
![[GAMES101_Lecture_08-18.jpeg]]

- [00:27:47](https://www.bilibili.com/video/BV1X7411F744?p=8#t=27:47.96) 
当然flat shading也不一定很差，取决于本身点面的情况
![[GAMES101_Lecture_08-19.jpeg]]

那么我们怎么算点的法线呢，一个方法是我们预想知道这个多边形本身的形状（比如本身是一个球）然后直接算出来法线，但不是很practical
另一个做法是顶点周围的面的法线量求平均，（当然可能有面积加权平均）
![[GAMES101_Lecture_08-20.jpeg]]


- [00:31:06](https://www.bilibili.com/video/BV1X7411F744?p=8#t=31:06.76) 那如何得到一个像素的法线呢，我们就设定一个得到一个平滑过渡的法线，注意要归一化
中间这个插值我们用重心坐标来算
![[GAMES101_Lecture_08-21.jpeg]]

# Real-time Rendering

- [00:32:56](https://www.bilibili.com/video/BV1X7411F744?p=8#t=32:56.24) 

![[GAMES101_Lecture_08-22.jpeg]]

![[GAMES101_Lecture_08-23.jpeg]]

![[GAMES101_Lecture_08-24.jpeg]]

![[GAMES101_Lecture_08-25.jpeg]]

![[GAMES101_Lecture_08-26.jpeg]]

![[GAMES101_Lecture_08-27.jpeg]]

还有一个材质的问题也就是纹理映射==texture mapping==
![[GAMES101_Lecture_08-28.jpeg]]



- [00:40:29](https://www.bilibili.com/video/BV1X7411F744?p=8#t=40:29.98) 可以自己编程实现shader，这个shader是通用的，每个像素自然会处理
![[GAMES101_Lecture_08-29.jpeg]]

![[GAMES101_Lecture_08-30.jpeg]]

![[GAMES101_Lecture_08-31.jpeg]]

![[GAMES101_Lecture_08-32.jpeg]]

![[GAMES101_Lecture_08-33.jpeg]]

![[GAMES101_Lecture_08-34.jpeg]]

![[GAMES101_Lecture_08-35.jpeg]]

# Textual Mapping
- [00:54:47](https://www.bilibili.com/video/BV1X7411F744?p=8#t=54:47.74) 
![[GAMES101_Lecture_08-36.jpeg]]

球上会有不同的颜色材质
![[GAMES101_Lecture_08-37.jpeg]]
其根本作用就是定义一个位置的属性，不只是用来处理shading

物体表面上的定义一个点的属性，都可以转换为2维
![[GAMES101_Lecture_08-38.jpeg]]

三角形映射到纹理上在哪个位置
![[GAMES101_Lecture_08-39.jpeg]]
可能自动化展开（参数化），或者美工完成
但我们这里不会进行研究

![[GAMES101_Lecture_08-40.jpeg]]

![[GAMES101_Lecture_08-41.jpeg]]

![[GAMES101_Lecture_08-42.jpeg]]

![[GAMES101_Lecture_08-43.jpeg]]
一块一块的映射上去
纹理设计的好，可以实现无缝衔接 tileable
![[GAMES101_Lecture_08-44.jpeg]]

![[GAMES101_Lecture_08-45.jpeg]]
