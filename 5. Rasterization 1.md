![[GAMES101_Lecture_05-1.jpeg]]

![[GAMES101_Lecture_05-3.jpeg]]

![[GAMES101_Lecture_05-4.jpeg]]

另一种描述方式：
![[GAMES101_Lecture_05-5.jpeg]]
定义视锥，用两个要素：长宽比，以及垂直可视角度

![[GAMES101_Lecture_05-6.jpeg]]
然后将其转换为之前所定义的模型

![[GAMES101_Lecture_05-7.jpeg]]

完成投影后，将设计如何在屏幕上进行成像
屏幕，可以视为一个二维的数组
![[GAMES101_Lecture_05-8.jpeg]]
raseter 光栅，我们先抽象的将一个像素看作一个颜色的点

- [00:18:31](https://www.bilibili.com/video/BV1X7411F744?p=5#t=18:31.91) 
![[GAMES101_Lecture_05-9.jpeg]]

一个(width, height)的屏幕，
![[GAMES101_Lecture_05-10.jpeg]]

我们将(-1,1)\*(-1,1)的范围转换为(0,width) \*(0,height)
![[GAMES101_Lecture_05-11.jpeg]]
这里的变换相当于z不动，然后缩放x y两个坐标，然后再位移，使得中心点保持一致

![[GAMES101_Lecture_05-12.jpeg]]

![[GAMES101_Lecture_05-16.jpeg]]

![[GAMES101_Lecture_05-17.jpeg]]

![[GAMES101_Lecture_05-18.jpeg]]

![[GAMES101_Lecture_05-19.jpeg]]

![[GAMES101_Lecture_05-20.jpeg]]
隔行扫描

现在是将内存中的区域映射出来
![[GAMES101_Lecture_05-21.jpeg]]

LCD
![[GAMES101_Lecture_05-22.jpeg]]

LCD 液晶显示器，通过自身排布来影响光
![[GAMES101_Lecture_05-23.jpeg]]

LED，发光二极管
![[GAMES101_Lecture_05-24.jpeg]]

![[GAMES101_Lecture_05-25.jpeg]]

![[GAMES101_Lecture_05-26.jpeg]]

![[GAMES101_Lecture_05-27.jpeg]]

![[GAMES101_Lecture_05-28.jpeg]]

![[GAMES101_Lecture_05-29.jpeg]]

- [00:39:38](https://www.bilibili.com/video/BV1X7411F744?p=5#t=39:38.12) 

![[GAMES101_Lecture_05-30.jpeg]]
任何多边形都可以拆解为三角形，
三角形内部一定是平面的（无对角线）
方便确定内部（不想凹凸多边形那样）
方便计算内部差值，渐变

那么光栅化的问题就是，如何用像素点来近似
![[GAMES101_Lecture_05-31.jpeg]]

![[GAMES101_Lecture_05-32.jpeg]]


- [00:43:55](https://www.bilibili.com/video/BV1X7411F744?p=5#t=43:55.95) 

我们通过采样的方法来确定
也就是将一个连续函数离散化的过程
![[GAMES101_Lecture_05-33.jpeg]]
各种东西都可以采样，这个思想非常重要

![[GAMES101_Lecture_05-34.jpeg]]

![[GAMES101_Lecture_05-35.jpeg]]
需要判断任何一个像素点的中心，是否在三角形内
![[GAMES101_Lecture_05-36.jpeg]]

![[GAMES101_Lecture_05-37.jpeg]]

中心在(x+0.5 y+0.5)上
![[GAMES101_Lecture_05-38.jpeg]]

![[GAMES101_Lecture_05-39.jpeg]]

- [00:49:06](https://www.bilibili.com/video/BV1X7411F744?p=5#t=49:06.61) 

那么我们具体如何判断是否在三角形内
![[GAMES101_Lecture_05-40.jpeg]]

通过三次叉乘即可

$\overrightarrow{P_1P_2}\times \overrightarrow{P_1Q}$ 根据右手定则，可知Q在$P_1P_2$的右侧还是左侧
![[GAMES101_Lecture_05-41.jpeg]]

那如果是临界状态呢，约定一个标准即可
![[GAMES101_Lecture_05-42.jpeg]]

但如果每次光栅化的时候，把每个屏幕上的像素点都拿来计算一遍，那肯定是低效的
因此我们先确定一个大致的范围 bounding box 然后来计算

- [00:54:36](https://www.bilibili.com/video/BV1X7411F744?p=5#t=54:36.09) 

这里这个是轴向的包围核 AABB（某些情况下很低效）
![[GAMES101_Lecture_05-43.jpeg]]

还有其他加速方法，在每一行找一个最左和最右边的边界
![[GAMES101_Lecture_05-44.jpeg]]

![[GAMES101_Lecture_05-45.jpeg]]

![[GAMES101_Lecture_05-46.jpeg]]
注意绿色的点其实要多一点

有可能还有省墨的需求
![[GAMES101_Lecture_05-47.jpeg]]

![[GAMES101_Lecture_05-48.jpeg]]

![[GAMES101_Lecture_05-49.jpeg]]

采样不足，可能有走样的问题
![[GAMES101_Lecture_05-50.jpeg]]

![[GAMES101_Lecture_05-51.jpeg]]

![[GAMES101_Lecture_05-52.jpeg]]

或者说是锯齿
![[GAMES101_Lecture_05-53.jpeg]]

![[GAMES101_Lecture_05-54.jpeg]]